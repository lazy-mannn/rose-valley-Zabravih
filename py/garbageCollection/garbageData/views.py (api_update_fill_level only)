@csrf_exempt
@require_http_methods(["POST"])
def api_update_fill_level(request):
    """
    Raspberry Pi sends data DURING collection.
    
    FLOW:
    1. Raspberry Pi captures image of bin
    2. AI classifies fill level (this is BEFORE emptying)
    3. Sends to Django
    4. Django records this as the "before emptying" level
    5. Django immediately marks bin as emptied (creates 0% record)
    6. Updates last_emptied timestamp
    
    This means: Every AI reading = collection event
    """
    try:
        data = json.loads(request.body)
        trashcan_id = data.get('trashcan_id')
        
        # Accept either fill_level or AI category
        fill_level = data.get('fill_level')
        category = data.get('category')
        
        if not trashcan_id:
            return JsonResponse({'success': False, 'error': 'Missing trashcan_id'}, status=400)
        
        # Convert AI category to fill level
        if category and not fill_level:
            fill_level = AI_CATEGORY_MAP.get(category.lower(), 50)
        
        if fill_level is None:
            return JsonResponse({'success': False, 'error': 'Missing fill_level or category'}, status=400)
        
        if fill_level < 0:
            return JsonResponse({'success': False, 'error': 'fill_level must be >= 0'}, status=400)
        
        trashcan = TrashCan.objects.get(id=trashcan_id)
        
        # Record the fill level BEFORE collection
        before_record = FillRecord.objects.create(
            trashcan=trashcan,
            fill_level=fill_level,
            source='ai'
        )
        
        # Immediately mark as emptied (bin is being collected RIGHT NOW)
        trashcan.mark_as_emptied()
        
        # Get updated prediction data
        predicted_fill = trashcan.get_predicted_fill_level()
        daily_rate = trashcan.get_average_daily_fill_rate()
        days_until_full = trashcan.get_days_until_full()
        
        return JsonResponse({
            'success': True,
            'trashcan_id': trashcan.id,
            'collected_at_fill_level': before_record.fill_level,
            'new_predicted_fill': predicted_fill,
            'updated_daily_rate': daily_rate,
            'days_until_full': days_until_full,
            'emptied_at': trashcan.last_emptied.isoformat(),
            'message': f'Bin collected at {fill_level}% and emptied'
        })
        
    except TrashCan.DoesNotExist:
        return JsonResponse({'success': False, 'error': 'Trash can not found'}, status=404)
    except json.JSONDecodeError:
        return JsonResponse({'success': False, 'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)}, status=500)